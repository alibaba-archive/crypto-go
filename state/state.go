package state

import (
	"encoding/base64"
	"encoding/binary"
	"errors"
	"time"

	"github.com/teambition/crypto-go"
	"golang.org/x/crypto/sha3"
)

// Sign generates a state string signed with SHA3 256.
// It is useful for OAuth2 or Webhook callback.
// base64RawURL(8 bytes time + 8 bytes nonce + 32 bytes sha3 256)
//
//  fmt.Println(Sign([]byte("my key"), ""))
//  // zILSqgsAAACNRsElhX2IP-HqOmhKKSMJDNv2f7G2ONo-ULM4G4zppTWTiSDKwCjc
//  fmt.Println(Sign([]byte("my key"), "some message"))
//  // zILSqgsAAAA01z-LM1BfpaW9l7dK9zPUUJZl1P0_Jr4yEgYWHSQ_bFeiGFKA6qq6
//
func Sign(key []byte, message string) string {
	nonce := make([]byte, 16)
	binary.PutVarint(nonce, time.Now().Unix())
	crypto.Rand(nonce[8:])
	s := sign(key, append([]byte(message), nonce...))
	return base64.RawURLEncoding.EncodeToString(append(nonce, s...))
}

// Verify Verify state that generated by Sign.
//
//  fmt.Println(Verify([]byte("my key"), "", state, 60 * time.Second)
//
func Verify(key []byte, message, state string, expire ...time.Duration) bool {
	s, err := base64.RawURLEncoding.DecodeString(state)
	if err != nil || len(s) != 48 {
		return false
	}

	if len(expire) > 0 {
		i, _ := binary.Varint(s[:8])
		if (i + int64(expire[0])/1e9) < time.Now().Unix() {
			return false
		}
	}
	return crypto.Equal(s[16:], sign(key, append([]byte(message), s[:16]...)))
}

// New creates an instance of States.
func New(keys ...[]byte) (*States, error) {
	if len(keys) == 0 || len(keys[0]) == 0 {
		return nil, errors.New("invalid keys")
	}
	return &States{keys: crypto.RotatingBytes(keys)}, nil
}

// States is a rotating Sign/Verify struct.
type States struct {
	keys crypto.RotatingBytes
}

// Sign generates a state string signed with SHA3 256.
// base64RawURL(8 bytes time + 8 bytes nonce + 32 bytes sha3 256)
func (s *States) Sign(message string) string {
	return Sign(s.keys[0], message)
}

// Verify Verify state that generated by Sign.
func (s *States) Verify(message, state string, expire ...time.Duration) bool {
	val, err := base64.RawURLEncoding.DecodeString(state)
	if err != nil || len(val) != 48 {
		return false
	}

	if len(expire) > 0 {
		i, _ := binary.Varint(val[:8])
		if (i + int64(expire[0])/1e9) < time.Now().Unix() {
			return false
		}
	}

	msg := append([]byte(message), val[:16]...)
	if s.keys.Verify(func(key []byte) bool {
		return crypto.Equal(val[16:], sign(key, msg))
	}) >= 0 {
		return true
	}
	return false
}

func sign(key, message []byte) []byte {
	return crypto.HmacSum(sha3.New256, key, message)
}
